# Merge conflict playbook

## Goals
- Resolve conflicts quickly and correctly with a repeatable, low-risk routine
- Preserve a clean history suitable for teaching and later audits
- Fit solo dev + trunk-preferred workflow with occasional feature branches

---

## Golden rules
1) Keep `main` always green and protected  
2) Prefer **rebase** onto `main` for feature branches (linear history)  
3) Commit only **logical conflict resolutions** (small, reviewed diffs)  
4) If unsure, **abort and branch off** to try again safely

---

## One-time setup
- Enable helpful defaults:
  - `git config --global pull.rebase true`
  - `git config --global rebase.autoStash true`
  - `git config --global rerere.enabled true`  ← Git will remember past resolutions
  - `git config --global diff.colorMoved zebra`
  - `git config --global merge.conflictStyle zdiff3`  ← shows base + both sides
- Add `.gitattributes` to avoid noisy conflicts:
  - `*.lock merge=ours`            ← lockfiles regenerated by CI
  - `*.min.js -diff`               ← treat minified assets as binary
  - `docs/** linguist-documentation` ← keeps focus in reviews
- Define a trivial merge driver (optional) in `.gitattributes`:
  - `docs/_build/** merge=ours`    ← generated docs prefer current branch

---

## Fast path: rebase a feature branch onto main
1) Ensure a clean working tree  
   - `git status` → no unstaged changes; stash or commit if needed
2) Update `main`  
   - `git checkout main`  
   - `git fetch origin`  
   - `git pull`  (rebase is default from setup)
3) Rebase your branch  
   - `git checkout my-feature`  
   - `git rebase main`
4) When conflicts appear:
   - Inspect files shown by Git
   - Open each conflicted file and look for markers:
     ```
     <<<<<<< HEAD
     your branch changes
     ||||||| base
     common ancestor
     =======
     main changes
     >>>>>>> main
     ```
   - Decide the correct result, edit to final content, then:
     - `git add <file>`
   - Continue:
     - `git rebase --continue`
   - If you mis-resolve, undo the step:
     - `git rebase --edit-todo` or `git rebase --abort` to restart
5) Run tests and linters  
   - `pytest -q` or project script  
   - fix, commit as needed during rebase (`git commit --amend` if same step)
6) Push with rewrite  
   - `git push --force-with-lease`

---

## Alternative: merge main into your branch
- Use when history rewriting is undesirable
  1) `git checkout my-feature`
  2) `git merge main`
  3) Resolve conflicts as above → `git add` → `git commit`
  4) Run tests → `git push`

---

## Typical conflict patterns and how to decide

- Same line edits in code  
  - Prefer the version that passes tests and keeps API contracts
  - If both are valid, integrate both logically and add a short comment
- Function moved/renamed in one side, edited on the other  
  - Keep the move/rename, then re-apply the edit in the new location
- Deleted in one branch, edited in the other  
  - If deletion was intentional (e.g., refactor), keep delete and port edit elsewhere
  - Otherwise, restore file and reconcile with refactor
- Generated files, lock files, compiled assets  
  - Favor **ours** side and regenerate; never hand-merge
- Markdown conflicts  
  - Prefer source of truth section ordering; re-run docs build or TOC generator

---

## Tactics that save time

- Stage hunks interactively  
  - `git add -p <file>` to review and stage piece-by-piece
- Use three-pane diff tools (optional)  
  - `git mergetool` with a visual diff (Meld, VS Code, Beyond Compare)
- Preempt conflicts by updating frequently  
  - `git fetch && git rebase main` at the start of each session
- Let Git remember your fixes  
  - With `rerere.enabled=true`, subsequent similar conflicts auto-resolve; still review

---

## Lazy but Dangerous

Of course, you'll often see me to `git add -A`. This is lazy, quick, but merge-dangerous.

## Abort, snapshot, and retry safely
- Abort a messy rebase  
  - `git rebase --abort`
- Snapshot current state before experiments  
  - `git switch -c rescue/<topic>-<date>` then try alternate resolutions
- Stash uncommitted changes  
  - `git stash -u` then rebase; `git stash pop` after

---

## Teaching-oriented command crib
- See what’s conflicted  
  - `git status`  
  - `git diff --name-only --diff-filter=U`
- Show only conflict hunks  
  - `git diff --cc` or `git log --merge -p`
- Continue / skip / abort during rebase  
  - `git rebase --continue`  
  - `git rebase --skip`  
  - `git rebase --abort`
- Force-push safely  
  - `git push --force-with-lease`

---

## Commit message template for conflict merges
- Title: `Resolve conflicts: <area/module>`  
- Body:
  - Why the chosen resolution is correct (one or two bullets)
  - Any follow-ups created (tests added, TODOs removed)
  - Reference to related ADR or PR if applicable

Example:
```
Resolve conflicts: blog/views and urls

- Kept main’s route restructure (`/posts/<slug>/`), reapplied feature’s
  pagination fix in new view function.
- Added unit test: pagination retains tag filter.
```

---

## Where this fits your gates
- Gate 1 Intent: note why you’re rebasing/merging and expected outcome
- Gate 2 Surface behavior: ensure CLI/URLs remain stable after resolution
- Gate 3 Tests: run unit/behave; add tests if conflict revealed a gap
- Gate 4 Docs: update README/CHANGELOG if routes or usage changed
- Gate 5 Attestation: record brief rationale in commit body or ADR snippet

---

## Quick triage checklist
- [ ] Working tree clean
- [ ] Rebased onto fresh `main`
- [ ] All conflicts resolved and staged
- [ ] Tests and linters pass locally
- [ ] Push with `--force-with-lease` if you rebased
- [ ] Short, explanatory commit message documenting choices

---

## Appendix: handy .gitattributes snippet
```
# Treat these as generated or low-value diffs
package-lock.json merge=ours
poetry.lock merge=ours
docs/_build/** merge=ours
*.min.js -diff
*.map -diff
*.svg -diff
```

---

## Appendix: minimal rescue flow
```
git status
git switch -c rescue/conflict-<date>
git rebase main
# resolve → add → continue
pytest -q
git push -u origin rescue/conflict-<date>
# open a quick PR or cherry-pick back onto feature
```